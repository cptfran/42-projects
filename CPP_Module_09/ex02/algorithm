
STEP 1: group the elements of x into [n/2] pairs of elements
"You start by grouping the elements into ([n/2]) pairs. If there's an odd number of elements, one element will remain
unpaired."

STEP 2: determine the larger of the two elements in each pair
"For each pair, determine which element is larger and which is smaller."

STEP 3: Recursively sort the [n/2] larger elements form each pair
"This forms the initial "main chain" or sequence. Divide the list of elements into two halves.
Recursively sort each half. Merge the two sorted halves into a single sorted sequence.
In the context of the Ford-Johnson algorithm, when you're sorting the pairs based on the larger numbers (which you've
mentioned are already the first element of each pair), you should consider each pair as an indivisible unit during the
sorting process. This means that when you sort the pairs based on the larger numbers (the first element of each pair),
you swap the whole pair as a unit, rather than just swapping the larger numbers within the pairs."
- Dividing the list into two halves.
- Sorting the larger elements (from each pair formed by pairing elements from the two halves) recursively.
- Merging these sorted elements into a "main chain" or sequence.
- Inserting the remaining elements into this main chain, also using a recursive process.

This approach ensures that the relationship between the larger and smaller numbers within each pair is maintained
throughout the sorting process. The "lower nums chain" or sequence of smaller numbers will indeed look different after
the sorting, as it will reflect the order of the pairs determined by the sorting of the larger numbers"

STEP 4: Create the main chain and pend
"This step involves inserting the smaller elements (from the initial pairs) into the sequence formed by the larger
elements. The insertion is done to maintain the sorted order. The method of insertion is where the algorithm gets more
complex and involves using previously determined positions to minimize comparisons."

STEP 5: Generate the order of insertion use jacobsthal sequence
"The Jacobsthal sequence (or a similar method) can be used to optimize the order of insertion for the smaller elements.
However, this is not a universally described step in all explanations of the Ford-Johnson algorithm. The key idea is to
minimize the number of comparisons needed to insert the remaining elements into the sorted sequence."

STEP 6: insert the elements of the pend into the main chain
"The remaining elements (the smaller ones from the initial pairs) are inserted into the sorted sequence of larger
elements. The insertion should maintain the sorted order, and the goal is to do this with the minimum number of
comparisons."
function insertUsingJacobsthal(mainChain, lowerChain, jacobsthalSeq):
    for each element in lowerChain:
        possiblePositions = getPossiblePositions(jacobsthalSeq, mainChain.size())
        correctPosition = findCorrectPosition(mainChain, element, possiblePositions)
        insert element into mainChain at correctPosition

function getPossiblePositions(jacobsthalSeq, size):
    positions = []
    for each number in jacobsthalSeq (in reverse):
        if number < size:
            positions.add(size - number)
    return positions

function findCorrectPosition(mainChain, element, possiblePositions):
    for each position in possiblePositions:
        if binarySearch confirms element fits at position:
            return position
    return some default position if not found

Note: binarySearch is a simplified representation. Actual implementation would adjust based on the sorted order.
Additional Clarifications:
"Main Chain and Pend: The terms "main chain" and "pend" are not universally used in descriptions of the Ford-Johnson
algorithm. Typically, the algorithm is described in terms of sorting a subset of elements (the larger ones from each
pair) and then efficiently inserting the remaining elements into this sorted subset."

Optimization Goal:
"The Ford-Johnson algorithm aims to reduce the total number of comparisons needed to sort a list, making it more
efficient than straightforward comparison-based sorting algorithms, especially for lists where comparisons are
expensive."

#include <cstdlib>
#include <stdexcept>
#include <cerrno>
#include <climits>
#include <vector>
#include <iostream>

template <typename ContainerBasic, typename ContainerPair>
PmergeMe<ContainerBasic, ContainerPair>::PmergeMe()
{

}

template <typename ContainerBasic, typename ContainerPair>
PmergeMe<ContainerBasic, ContainerPair>::PmergeMe(int argc, char **argv)
{
	for (int i = 1; i < argc; ++i)
	{
		errno = 0;
		char *endPtr;
		long num = std::strtol(argv[i], &endPtr, 10);
		if (endPtr == argv[i] || *endPtr != '\0' || errno == ERANGE || num < INT_MIN || num > INT_MAX)
		{
			throw std::invalid_argument("Error: invalid input");
		}
		if (num < 0)
		{
			throw std::invalid_argument("Error: not a positive integer");
		}
		nums.push_back(static_cast<int>(num));
	}
	for (size_t i = 0; i + 1 < this->nums.size(); i += 2)
	{
		this->numsPairs.push_back(std::make_pair(this->nums[i], this->nums[i + 1]));
	}
}

template <typename ContainerBasic, typename ContainerPair>
PmergeMe<ContainerBasic, ContainerPair>::PmergeMe(const PmergeMe<ContainerBasic, ContainerPair>& toCopy)
	: nums(toCopy.nums), numsPairs(toCopy.numsPairs)
{

}

template <typename ContainerBasic, typename ContainerPair>
PmergeMe<ContainerBasic, ContainerPair>& PmergeMe<ContainerBasic, ContainerPair>::operator=(const PmergeMe<ContainerBasic, ContainerPair>& toCopy)
{
	if (this != &toCopy)
	{
		this->nums = toCopy.nums;
		this->numsPairs = toCopy.numsPairs;
	}
	return *this;
}

template <typename ContainerBasic, typename ContainerPair>
PmergeMe<ContainerBasic, ContainerPair>::~PmergeMe()
{

}

template <typename ContainerBasic, typename ContainerPair>
void PmergeMe<ContainerBasic, ContainerPair>::sortFordJohnson()
{
// "For each pair, determine which element is larger and which is smaller."
	this->moveLargerInPairFirst();

// "Divide the list into two halves"
// "Recursively sort the larger elements from each pair. This forms the initial 'main chain' or sequence."
	this->splitAndInsertionSort();

// "This step involves inserting the smaller elements (from the initial pairs) into the sequence formed by the
// larger elements. The insertion is done to maintain the sorted order. The method of insertion is where the
// algorithm gets more complex and involves using previously determined positions to minimize comparisons."
	this->createMainAndLowerChain();

//	"Init Jacobsthal sequence that will help to insert remaining elements into the main chain"
	this->initJacobsthalSequence(mainChain.size() + lowerChain.size());

//	"The remaining elements (the smaller ones from the initial pairs) are inserted into the sorted sequence of larger
//	elements. The insertion should maintain the sorted order, and the goal is to do this with the minimum number of
//	comparisons."
	this->insertLowerChainNumsToMainChain();
}

template <typename ContainerBasic, typename ContainerPair>
void PmergeMe<ContainerBasic, ContainerPair>::moveLargerInPairFirst()
{
	std::cout << GRAY "\nSTEP 1 && STEP 2: group the elements of x into [n/2] pairs of elements determine the "
	             "larger of the two elements in each pair" RESET << std::endl;
	for (size_t i = 0; i < this->numsPairs.size(); ++i)
	{
		if (this->numsPairs[i].first < this->numsPairs[i].second)
		{
			std::swap(this->numsPairs[i].first, this->numsPairs[i].second);
		}
		std::cout << this->numsPairs[i].first << " " << this->numsPairs[i].second << std::endl;
	}
}

template <typename ContainerBasic, typename ContainerPair>
void PmergeMe<ContainerBasic,ContainerPair>::splitAndInsertionSort()
{
	std::cout << GRAY "\nSTEP 3: Divide list into 2 halves. Recursively sort the larger elements from each pair" RESET
		<< std::endl;
	size_t midIdxNumsPairs = this->numsPairs.size() / 2;
	for (size_t i = 0; i < this->numsPairs.size(); ++i)
	{
		if (i < midIdxNumsPairs)
		{
			this->firstHalf.push_back(this->numsPairs[i]);
		}
		else
		{
			this->secondHalf.push_back(this->numsPairs[i]);
		}
	}
	this->recursiveInsertionSort(this->firstHalf, this->firstHalf.size());
	this->recursiveInsertionSort(this->secondHalf, this->secondHalf.size());
	for (size_t i = 0; i < this->firstHalf.size(); ++i)
	{
		std::cout << "firstHalf: " << this->firstHalf[i].first << " " << this->firstHalf[i].second << std::endl;
	}
	for (size_t i = 0; i < this->secondHalf.size(); ++i)
	{
		std::cout << "secondHalf: " << this->secondHalf[i].first << " " << this->secondHalf[i].second << std::endl;
	}
}

template <typename ContainerBasic, typename ContainerPair>
void PmergeMe<ContainerBasic, ContainerPair>::recursiveInsertionSort(ContainerPair& list, int listSize)
{
	if (listSize <= 1)
		return;
	this->recursiveInsertionSort(list, listSize - 1);
	typename ContainerPair::value_type last = list[listSize - 1];
	int j = listSize - 2;
	for (; j >= 0 && list[j].first >= last.first; --j)
	{
		list[j + 1] = list[j];
	}
	list[j + 1] = last;
}

template <typename ContainerBasic, typename ContainerPair>
void PmergeMe<ContainerBasic, ContainerPair>::createMainAndLowerChain()
{
	std::cout << GRAY "\nSTEP 4: Create main and lower chain" RESET << std::endl;
	size_t i = 0, j = 0;
	while (i < this->firstHalf.size() && j < this->secondHalf.size())
	{
		if (this->firstHalf[i].first < this->secondHalf[j].first)
		{
			mainChain.push_back(this->firstHalf[i].first);
			lowerChain.push_back(this->firstHalf[i].second);
			++i;
		}
		else
		{
			mainChain.push_back(this->secondHalf[j].first);
			lowerChain.push_back(this->secondHalf[j].second);
			++j;
		}
	}
	while (i < this->firstHalf.size())
	{
		mainChain.push_back(this->firstHalf[i].first);
		lowerChain.push_back(this->firstHalf[i].second);
		++i;
	}
	while (j < this->secondHalf.size())
	{
		mainChain.push_back(this->secondHalf[j].first);
		lowerChain.push_back(this->secondHalf[j].second);
		++j;
	}
	std::cout << "main chain: ";
	for (size_t k = 0; k < mainChain.size(); ++k)
	{
		std::cout << mainChain[k] << " ";
	}
	std::cout << "\nlower chain: ";
	for (size_t k = 0; k < lowerChain.size(); ++k)
	{
		std::cout << lowerChain[k] << " ";
	}
	std::cout << std::endl;
}

template <typename ContainerBasic, typename ContainerPair>
void PmergeMe<ContainerBasic, ContainerPair>::initJacobsthalSequence(size_t n)
{
	std::cout << GRAY "\nSTEP 5: Init Jacobsthal sequence that will help to insert remaining elements into the main "
					  "chain" RESET << std::endl;
	jacobsthalSeq.push_back(0);
	if (n <= 1)
	{
		return;
	}
	jacobsthalSeq.push_back(1);
	for (size_t i = 2; i < n; ++i)
	{
		jacobsthalSeq.push_back(jacobsthalSeq[i - 2] * 2 + jacobsthalSeq[i - 1]);
	}
	std::cout << "Jacobsthal sequence: ";
	for (size_t i = 0; i < n; ++i)
	{
		std::cout << jacobsthalSeq[i] << " ";
	}
	std::cout << std::endl;
}

template <typename ContainerBasic, typename ContainerPair>
void PmergeMe<ContainerBasic, ContainerPair>::insertLowerChainNumsToMainChain()
{
	for (size_t i = 0; i < lowerChain.size(); ++i)
	{
		ContainerBasic possiblePositions = getPossiblePositions();
		int correctPosition = findInsertPosition(mainChain, lowerChain[i]);
		//insert element into mainChain at correctPosition
		mainChain.insert(mainChain.begin() + correctPosition, lowerChain[i]);
	}
	std::cout << GRAY "\nSTEP 6: insert the elements of the lower chain into the main chain " RESET << std::endl;
	for (size_t i = 0; i < mainChain.size(); ++i)
	{
		std::cout << mainChain[i] << " " << std::endl;
	}
}

template <typename ContainerBasic, typename ContainerPair>
int PmergeMe<ContainerBasic, ContainerPair>::findInsertPosition(const ContainerBasic& chain, int element)
{
	int low = 0, high = chain.size();
	while (low < high)
	{
		int mid = low + (high - low) / 2;
		if (chain[mid] < element)
			low = mid + 1;
		else
			high = mid;
	}
	return low; // This is the correct position for insertion
}

template <typename ContainerBasic, typename ContainerPair>
ContainerBasic PmergeMe<ContainerBasic, ContainerPair>::getPossiblePositions()
{
	ContainerBasic positions;
	for (int i = jacobsthalSeq.size() - 1; i >= 0; --i)
	{
		if (jacobsthalSeq[i] < static_cast<int>(mainChain.size()))
		{
			positions.push_back(mainChain.size() - jacobsthalSeq[i]);
		}
	}
	return positions;
}

template <typename ContainerBasic, typename ContainerPair>
int PmergeMe<ContainerBasic, ContainerPair>::findCorrectPosition(int element, ContainerBasic& possiblePositions)
{
	for (size_t i = 0; i < possiblePositions.size(); ++i)
	{
		if (binarySearch(element, possiblePositions[i]))
			return possiblePositions[i];
	}
	//return some default position if not found
	return mainChain.size();
}

template <typename ContainerBasic, typename ContainerPair>
bool PmergeMe<ContainerBasic, ContainerPair>::binarySearch(int element, int position)
{
	if (position == 0)
	{
		return element < mainChain[position];
	}
	if (position == static_cast<int>(mainChain.size()))
	{
		return element > mainChain.back();
	}
	if (element > mainChain[position - 1] && element < mainChain[position])
	{
		return true;
	}
	return false;
}